<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Promise 常见问题总结 | Hello World</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="源自 We have a problem with promises Fellow JavaScripters, it’s time to admit it: we have a problem with promises. No, not with promises themselves. Promises, as defined by the A+ spec, are awesome. The">
<meta name="keywords" content="Javascript,Reprint">
<meta property="og:type" content="article">
<meta property="og:title" content="Promise 常见问题总结">
<meta property="og:url" content="http://dukegod.github.io/2017/04/10/2017-04-10-Javascript-Promise-problems/index.html">
<meta property="og:site_name" content="Hello World">
<meta property="og:description" content="源自 We have a problem with promises Fellow JavaScripters, it’s time to admit it: we have a problem with promises. No, not with promises themselves. Promises, as defined by the A+ spec, are awesome. The">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-11-10T15:18:13.543Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Promise 常见问题总结">
<meta name="twitter:description" content="源自 We have a problem with promises Fellow JavaScripters, it’s time to admit it: we have a problem with promises. No, not with promises themselves. Promises, as defined by the A+ spec, are awesome. The">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
      <!---  <a href="/" id="logo">Hello World</a> -->
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about.html">About</a>
        
          <a class="main-nav-link" href="/resume.html">Resume</a>
        
          <a class="main-nav-link" href="/atom.xml">rss</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://dukegod.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2017-04-10-Javascript-Promise-problems" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/10/2017-04-10-Javascript-Promise-problems/" class="article-date">
  <time datetime="2017-04-09T16:00:00.000Z" itemprop="datePublished">2017-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Promise 常见问题总结
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" target="_blank" rel="noopener">源自</a></p>
<p>We have a problem with promises</p>
<p>Fellow JavaScripters, it’s time to admit it: we have a problem with promises.</p>
<p>No, not with promises themselves. Promises, as defined by the A+ spec, are awesome.</p>
<p>The big problem, which has revealed itself to me over the course of the past year, as I’ve watched numerous programmers struggle with the PouchDB API and other promise-heavy APIs, is this:</p>
<p>Many of us are using promises without really understanding them.</p>
<p>If you find that hard to believe, consider this puzzle I recently posted to Twitter:</p>
<p>Q: What is the difference between these four promises?</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">doSomething().<span class="keyword">then</span>(<span class="keyword">function</span> <span class="title"></span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">doSomethingElse()</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">doSomething().<span class="keyword">then</span>(<span class="keyword">function</span> <span class="title"></span>() &#123;</span><br><span class="line">  doSomethingElse();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">doSomething().<span class="keyword">then</span>(doSomethingElse());</span><br><span class="line"></span><br><span class="line">doSomething().<span class="keyword">then</span>(doSomethingElse);</span><br></pre></td></tr></table></figure>
<p>If you know the answer, then congratulations: you’re a promises ninja. You have my permission to stop reading this blog post.</p>
<p>For the other 99.99% of you, you’re in good company. Nobody who responded to my tweet could solve it, and I myself was surprised by the answer to #3. Yes, even though I wrote the quiz!</p>
<p>The answers are at the end of this post, but first, I’d like to explore why promises are so tricky in the first place, and why so many of us – novices and experts alike – get tripped up by them. I’m also going to offer what I consider to be the singular insight, the one weird trick, that makes promises a cinch to understand. And yes, I really do believe they’re not so hard after that!</p>
<p>But to start with, let’s challenge some common assumptions about promises.</p>
<a id="more"></a>
<p>Wherefore promises?</p>
<p>If you read the literature on promises, you’ll often find references to the pyramid of doom, with some horrible callback-y code that steadily stretches toward the right side of the screen.</p>
<p>Promises do indeed solve this problem, but it’s about more than just indentation. As explained in the brilliant talk “Redemption from Callback Hell”, the real problem with callbacks it that they deprive us of keywords like return and throw. Instead, our program’s entire flow is based on side effects: one function incidentally calling another one.</p>
<p>And in fact, callbacks do something even more sinister: they deprive us of the stack, which is something we usually take for granted in programming languages. Writing code without a stack is a lot like driving a car without a brake pedal: you don’t realize how badly you need it, until you reach for it and it’s not there.</p>
<p>The whole point of promises is to give us back the language fundamentals we lost when we went async: return, throw, and the stack. But you have to know how to use promises correctly in order to take advantage of them.</p>
<p>Rookie mistakes</p>
<p>Some people try to explain promises as a cartoon, or in a very noun-oriented way: “Oh, it’s this thing you can pass around that represents an asynchronous value.”</p>
<p>I don’t find such explanations very helpful. To me, promises are all about code structure and flow. So I think it’s better to just go over some common mistakes and show how to fix them. I call these “rookie mistakes” in the sense of, “you’re a rookie now, kid, but you’ll be a pro soon.”</p>
<p>Quick digression: “promises” mean a lot of different things to different people, but for the purposes of this article, I’m only going to talk about the official spec, as exposed in modern browsers as window.Promise. Not all browsers have window.Promise though, so for a good polyfill, check out the cheekily-named Lie, which is about the smallest spec-compliant library out there.</p>
<p>Rookie mistake #1: the promisey pyramid of doom</p>
<p>Looking at how people use PouchDB, which has a largely promise-based API, I see a lot of poor promise patterns. The most common bad practice is this one:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">remotedb.allDocs(&#123;</span><br><span class="line">  include_docs: <span class="literal">true</span>,</span><br><span class="line">  attachments: <span class="literal">true</span></span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(result)</span></span> &#123;</span><br><span class="line">  var docs = result.rows;</span><br><span class="line">  docs.forEach(<span class="function"><span class="keyword">function</span><span class="params">(element)</span></span> &#123;</span><br><span class="line">    localdb.put(element.doc).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(response)</span></span> &#123;</span><br><span class="line">      alert(<span class="string">"Pulled doc with id "</span> + element.doc._id + <span class="string">" and added to local db."</span>);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err.name == <span class="string">'conflict'</span>) &#123;</span><br><span class="line">        localdb.get(element.doc._id).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(resp)</span></span> &#123;</span><br><span class="line">          localdb.<span class="built_in">remove</span>(resp._id, resp._rev).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(resp)</span></span> &#123;</span><br><span class="line">// et cetera...</span><br></pre></td></tr></table></figure>
<p>Yes, it turns out you can use promises as if they were callbacks, and yes, it’s a lot like using a power sander to file your nails, but you can do it.</p>
<p>And if you think this sort of mistake is only limited to absolute beginners, you’ll be surprised to learn that I actually took the above code from the official BlackBerry developer blog! Old callback habits die hard. (And to the developer: sorry to pick on you, but your example is instructive.)</p>
<p>A better style is this one:</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">remotedb.allDocs(...).<span class="keyword">then</span>(<span class="keyword">function</span> <span class="title"></span>(resultOfAllDocs) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">localdb.put(...)</span>;</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span> <span class="title"></span>(resultOfPut) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">localdb.get(...)</span>;</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span> <span class="title"></span>(resultOfGet) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">localdb.put(...)</span>;</span><br><span class="line">&#125;).catch(<span class="keyword">function</span> <span class="title"></span>(err) &#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>This is called composing promises, and it’s one of the great superpowers of promises. Each function will only be called when the previous promise has resolved, and it’ll be called with that promise’s output. More on that later.</p>
<p>Rookie mistake #2: WTF, how do I use forEach() with promises?</p>
<p>This is where most people’s understanding of promises starts to break down. As soon as they reach for their familiar forEach() loop (or for loop, or while loop), they have no idea how to make it work with promises. So they write something like this:</p>
<p>// I want to remove() all docs</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">db.allDocs(&#123;include_docs: <span class="literal">true</span>&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(result)</span></span> &#123;</span><br><span class="line">  result.rows.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(row)</span></span> &#123;</span><br><span class="line">    db.<span class="built_in">remove</span>(row.doc);  </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  // I naively believe all docs have been removed() now!</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>What’s the problem with this code? The problem is that the first function is actually returning undefined, meaning that the second function isn’t waiting for db.remove() to be called on all the documents. In fact, it isn’t waiting on anything, and can execute when any number of docs have been removed!</p>
<p>This is an especially insidious bug, because you may not notice anything is wrong, assuming PouchDB removes those documents fast enough for your UI to be updated. The bug may only pop up in the odd race conditions, or in certain browsers, at which point it will be nearly impossible to debug.</p>
<p>The TLDR of all this is that forEach()/for/while are not the constructs you’re looking for. You want Promise.all():</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">db.allDocs(&#123;include_docs: <span class="literal">true</span>&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(result)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Promise.all(result.rows.map(<span class="function"><span class="keyword">function</span> <span class="params">(row)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> db.<span class="built_in">remove</span>(row.doc);</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(arrayOfResults)</span></span> &#123;</span><br><span class="line">  // All docs have really been removed() now!</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>What’s going on here? Basically Promise.all() takes an array of promises as input, and then it gives you another promise that only resolves when every one of those other promises has resolved. It is the asynchronous equivalent of a for-loop.</p>
<p>Promise.all() also passes an array of results to the next function, which can get very useful, for instance if you are trying to get() multiple things from PouchDB. The all() promise is also rejected if any one of its sub-promises are rejected, which is even more useful.</p>
<p>Rookie mistake #3: forgetting to add .catch()</p>
<p>This is another common mistake. Blissfully confident that their promises could never possibly throw an error, many developers forget to add a .catch() anywhere in their code. Unfortunately this means that any thrown errors will be swallowed, and you won’t even see them in your console. This can be a real pain to debug.</p>
<p>To avoid this nasty scenario, I’ve gotten into the habit of simply adding the following code to my promise chains:</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">somePromise().<span class="keyword">then</span>(<span class="keyword">function</span> <span class="title"></span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">anotherPromise()</span>;</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span> <span class="title"></span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">yetAnotherPromise()</span>;</span><br><span class="line">&#125;).catch(console.log.bind(console)); // &lt;<span class="comment">-- this is badass</span></span><br></pre></td></tr></table></figure>
<p>Even if you never expect an error, it’s always prudent to add a catch(). It’ll make your life easier, if your assumptions ever turn out to be wrong.</p>
<p>Rookie mistake #4: using “deferred”</p>
<p>This is a mistake I see all the time, and I’m reluctant to even repeat it here, for fear that, like Beetlejuice, merely invoking its name will summon more instances of it.</p>
<p>In short, promises have a long and storied history, and it took the JavaScript community a long time to get them right. In the early days, jQuery and Angular were using this “deferred” pattern all over the place, which has now been replaced with the ES6 Promise spec, as implemented by “good” libraries like Q, When, RSVP, Bluebird, Lie, and others.</p>
<p>So if you are writing that word in your code (I won’t repeat it a third time!), you are doing something wrong. Here’s how to avoid it.</p>
<p>First off, most promise libraries give you a way to “import” promises from third-party libraries. For instance, Angular’s $q module allows you to wrap non-$q promises using $q.when(). So Angular users can wrap PouchDB promises this way:</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$q.when(db.<span class="built_in">put</span>(doc)).<span class="keyword">then</span>(<span class="comment">/* ... */</span>);<span class="comment"> // &lt;-- this is all the code you need</span></span><br></pre></td></tr></table></figure>
<p>Another strategy is to use the revealing constructor pattern, which is useful for wrapping non-promise APIs. For instance, to wrap a callback-based API like Node’s fs.readFile(), you can simply do:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">'myfile.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(file);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then(<span class="comment">/* ... */</span>)</span><br></pre></td></tr></table></figure>
<p>Done! We have defeated the dreaded def… Aha, caught myself. :)</p>
<p>Rookie mistake #5: using side effects instead of returning</p>
<p>What’s wrong with this code?</p>
<figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line">somePromise().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">  someOtherPromise();</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">  <span class="comment">// Gee, I hope someOtherPromise() has resolved!</span></span><br><span class="line">  <span class="comment">// Spoiler alert: it hasn't.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Okay, this is a good point to talk about everything you ever need to know about promises.</p>
<p>Seriously, this is the one weird trick that, once you understand it, will prevent all of the errors I’ve been talking about. You ready?</p>
<p>As I said before, the magic of promises is that they give us back our precious return and throw. But what does this actually look like in practice?</p>
<p>Every promise gives you a then() method (or catch(), which is just sugar for then(null, …)). Here we are inside of a then() function:</p>
<figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line">somePromise().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">  <span class="comment">// I'm inside a then() function!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>What can we do here? There are three things:</p>
<p>return another promise<br>return a synchronous value (or undefined)<br>throw a synchronous error<br>That’s it. Once you understand this trick, you understand promises. So let’s go through each point one at a time.</p>
<ol>
<li>Return another promise</li>
</ol>
<p>This is a common pattern you see in the promise literature, as in the “composing promises” example above:</p>
<figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(user)</span> &#123;</span></span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(userAccount)</span> &#123;</span></span><br><span class="line">  <span class="comment">// I got a user account!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Notice that I’m returning the second promise – that return is crucial. If I didn’t say return, then the getUserAccountById() would actually be a side effect, and the next function would receive undefined instead of the userAccount.</p>
<ol start="2">
<li>Return a synchronous value (or undefined)</li>
</ol>
<p>Returning undefined is often a mistake, but returning a synchronous value is actually an awesome way to convert synchronous code into promisey code. For instance, let’s say we have an in-memory cache of users. We can do:</p>
<figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(user)</span> &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class="line">    <span class="keyword">return</span> inMemoryCache[user.id];    <span class="comment">// returning a synchronous value!</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id); <span class="comment">// returning a promise!</span></span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(userAccount)</span> &#123;</span></span><br><span class="line">  <span class="comment">// I got a user account!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Isn’t that awesome? The second function doesn’t care whether the userAccount was fetched synchronously or asynchronously, and the first function is free to return either a synchronous or asynchronous value.</p>
<p>Unfortunately, there’s the inconvenient fact that non-returning functions in JavaScript technically return undefined, which means it’s easy to accidentally introduce side effects when you meant to return something.</p>
<p>For this reason, I make it a personal habit to always return or throw from inside a then() function. I’d recommend you do the same.</p>
<ol start="3">
<li>Throw a synchronous error</li>
</ol>
<p>Speaking of throw, this is where promises can get even more awesome. Let’s say we want to throw a synchronous error in case the user is logged out. It’s quite easy:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (user.isLoggedOut()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'user logged out!'</span>); <span class="comment">// throwing a synchronous error!</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class="line">    <span class="keyword">return</span> inMemoryCache[user.id];       <span class="comment">// returning a synchronous value!</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id);    <span class="comment">// returning a promise!</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I got a user account!</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Boo, I got an error!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Our catch() will receive a synchronous error if the user is logged out, and it will receive an asynchronous error if any of the promises are rejected. Again, the function doesn’t care whether the error it gets is synchronous or asynchronous.</p>
<p>This is especially useful because it can help identify coding errors during development. For instance, if at any point inside of a then() function, we do a JSON.parse(), it might throw a synchronous error if the JSON is invalid. With callbacks, that error would get swallowed, but with promises, we can simply handle it inside our catch() function.</p>
<p>Advanced mistakes</p>
<p>Okay, now that you’ve learned the single trick that makes promises dead-easy, let’s talk about the edge cases. Because of course, there are always edge cases.</p>
<p>These mistakes I’d classify as “advanced,” because I’ve only seen them made by programmers who are already fairly adept with promises. But we’re going to need to discuss them, if we want to be able to solve the puzzle I posed at the beginning of this post.</p>
<p>Advanced mistake #1: not knowing about Promise.resolve()</p>
<p>As I showed above, promises are very useful for wrapping synchronous code as asynchronous code. However, if you find yourself typing this a lot:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(someSynchronousValue);</span><br><span class="line">&#125;).then(<span class="comment">/* ... */</span>);</span><br></pre></td></tr></table></figure>
<p>You can express this more succinctly using Promise.resolve():</p>
<p>Promise.resolve(someSynchronousValue).then(…);<br>This is also incredibly useful for catching any synchronous errors. It’s so useful, that I’ve gotten in the habit of beginning nearly all of my promise-returning API methods like this:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">somePromiseAPI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    doSomethingThatMayThrow();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'foo'</span>;</span><br><span class="line">  &#125;).then(<span class="comment">/* ... */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Just remember: any code that might throw synchronously is a good candidate for a nearly-impossible-to-debug swallowed error somewhere down the line. But if you wrap everything in Promise.resolve(), then you can always be sure to catch() it later.</p>
<p>Similarly, there is a Promise.reject() that you can use to return a promise that is immediately rejected:</p>
<p>Promise.reject(new Error(‘some awful error’));<br>Advanced mistake #2: catch() isn’t exactly like then(null, …)</p>
<p>I said above that catch() is just sugar. So these two snippets are equivalent:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">somePromise().<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">somePromise().then(<span class="keyword">null</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>However, that doesn’t mean that the following two snippets are equivalent:</p>
<figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line">somePromise().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">  <span class="keyword">return</span> someOtherPromise();</span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> &#123;</span></span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">somePromise().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">  <span class="keyword">return</span> someOtherPromise();</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> &#123;</span></span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>If you’re wondering why they’re not equivalent, consider what happens if the first function throws an error:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh noes'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I caught your error! :)</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh noes'</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I didn't catch your error! :(</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>As it turns out, when you use the then(resolveHandler, rejectHandler) format, the rejectHandler won’t actually catch an error if it’s thrown by the resolveHandler itself.</p>
<p>For this reason, I’ve made it a personal habit to never use the second argument to then(), and to always prefer catch(). The exception is when I’m writing asynchronous Mocha tests, where I might write a test to ensure that an error is thrown:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should throw an error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doSomethingThatThrows().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'I expected an error!'</span>);</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    should.exist(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Speaking of which, Mocha and Chai are a lovely combination for testing promise APIs. The pouchdb-plugin-seed project has some sample tests that can get you started.</p>
<p>Advanced mistake #3: promises vs promise factories</p>
<p>Let’s say you want to execute a series of promises one after the other, in a sequence. That is, you want something like Promise.all(), but which doesn’t execute the promises in parallel.</p>
<p>You might naïvely write something like this:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeSequentially</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  promises.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">promise</span>) </span>&#123;</span><br><span class="line">    result = result.then(promise);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Unfortunately, this will not work the way you intended. The promises you pass in to executeSequentially() will still execute in parallel.</p>
<p>The reason this happens is that you don’t want to operate over an array of promises at all. Per the promise spec, as soon as a promise is created, it begins executing. So what you really want is an array of promise factories:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeSequentially</span>(<span class="params">promiseFactories</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  promiseFactories.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">promiseFactory</span>) </span>&#123;</span><br><span class="line">    result = result.then(promiseFactory);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I know what you’re thinking: “Who the hell is this Java programmer, and why is he talking about factories?” A promise factory is very simple, though – it’s just a function that returns a promise:</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">myPromiseFactory</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">somethingThatCreatesAPromise()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Why does this work? It works because a promise factory doesn’t create the promise until it’s asked to. It works the same way as a then function – in fact, it’s the same thing!</p>
<p>If you look at the executeSequentially() function above, and then imagine myPromiseFactory being substituted inside of result.then(…), then hopefully a light bulb will click in your brain. At that moment, you will have achieved promise enlightenment.</p>
<p>Advanced mistake #4: okay, what if I want the result of two promises?</p>
<p>Often times, one promise will depend on another, but we’ll want the output of both promises. For instance:</p>
<figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(user)</span> &#123;</span></span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(userAccount)</span> &#123;</span></span><br><span class="line">  <span class="comment">// dangit, I need the "user" object too!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Wanting to be good JavaScript developers and avoid the pyramid of doom, we might just store the user object in a higher-scoped variable:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">var user;</span><br><span class="line">getUserByName(<span class="string">'nolan'</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(result)</span></span> &#123;</span><br><span class="line">  user = result;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(userAccount)</span></span> &#123;</span><br><span class="line">  // okay, I have both the <span class="string">"user"</span> <span class="keyword">and</span> the <span class="string">"userAccount"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>This works, but I personally find it a bit kludgey. My recommended strategy: just let go of your preconceptions and embrace the pyramid:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(user)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(userAccount)</span></span> &#123;</span><br><span class="line">    // okay, I have both the <span class="string">"user"</span> <span class="keyword">and</span> the <span class="string">"userAccount"</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>…at least, temporarily. If the indentation ever becomes an issue, then you can do what JavaScript developers have been doing since time immemorial, and extract the function into a named function:</p>
<figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onGetUserAndUserAccount</span><span class="params">(user, userAccount)</span> &#123;</span></span><br><span class="line">  <span class="keyword">return</span> doSomething(user, userAccount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onGetUser</span><span class="params">(user)</span> &#123;</span></span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(userAccount)</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> onGetUserAndUserAccount(user, userAccount);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserByName(<span class="string">'nolan'</span>)</span><br><span class="line">  .<span class="keyword">then</span>(onGetUser)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">  <span class="comment">// at this point, doSomething() is done, and we are back to indentation 0</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>As your promise code starts to get more complex, you may find yourself extracting more and more functions into named functions. I find this leads to very aesthetically-pleasing code, which might look like this:</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">putYourRightFootIn</span>()</span><br><span class="line">  <span class="selector-class">.then</span>(putYourRightFootOut)</span><br><span class="line">  <span class="selector-class">.then</span>(putYourRightFootIn)  </span><br><span class="line">  <span class="selector-class">.then</span>(shakeItAllAbout);</span><br></pre></td></tr></table></figure>
<p>That’s what promises are all about.</p>
<p>Advanced mistake #5: promises fall through</p>
<p>Finally, this is the mistake I alluded to when I introduced the promise puzzle above. This is a very esoteric use case, and it may never come up in your code, but it certainly surprised me.</p>
<p>What do you think this code prints out?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>).then(<span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>)).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>If you think it prints out bar, you’re mistaken. It actually prints out foo!</p>
<p>The reason this happens is because when you pass then() a non-function (such as a promise), it actually interprets it as then(null), which causes the previous promise’s result to fall through. You can test this yourself:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>).then(<span class="literal">null</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Add as many then(null)s as you want; it will still print foo.</p>
<p>This actually circles back to the previous point I made about promises vs promise factories. In short, you can pass a promise directly into a then() method, but it won’t do what you think it’s doing. then() is supposed to take a function, so most likely you meant to do:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>This will print bar, as we expected.</p>
<p>So just remind yourself: always pass a function into then()!</p>
<p>Solving the puzzle</p>
<p>Now that we’ve learned everything there is to know about promises (or close to it!), we should be able to solve the puzzle I originally posed at the start of this post.</p>
<p>Here is the answer to each one, in graphical format so you can better visualize it:</p>
<p>Puzzle #1</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">doSomething().<span class="keyword">then</span>(<span class="keyword">function</span> <span class="title"></span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">doSomethingElse()</span>;</span><br><span class="line">&#125;).<span class="keyword">then</span>(finalHandler);</span><br></pre></td></tr></table></figure>
<p>Answer:</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|<span class="string">-----------------</span>|</span><br><span class="line">                  doSomethingElse(undefined)</span><br><span class="line">                  |<span class="string">------------------</span>|</span><br><span class="line">                                     finalHandler(resultOfDoSomethingElse)</span><br><span class="line">                                     |<span class="string">------------------</span>|</span><br></pre></td></tr></table></figure>
<p>Puzzle #2</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">doSomething().<span class="keyword">then</span>(<span class="keyword">function</span> <span class="title"></span>() &#123;</span><br><span class="line">  doSomethingElse();</span><br><span class="line">&#125;).<span class="keyword">then</span>(finalHandler);</span><br></pre></td></tr></table></figure>
<p>Answer:</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|<span class="string">-----------------</span>|</span><br><span class="line">                  doSomethingElse(undefined)</span><br><span class="line">                  |<span class="string">------------------</span>|</span><br><span class="line">                  finalHandler(undefined)</span><br><span class="line">                  |<span class="string">------------------</span>|</span><br></pre></td></tr></table></figure>
<p>Puzzle #3</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">doSomething</span>()<span class="selector-class">.then</span>(doSomethingElse())</span><br><span class="line">  <span class="selector-class">.then</span>(finalHandler);</span><br></pre></td></tr></table></figure>
<p>Answer:</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|<span class="string">-----------------</span>|</span><br><span class="line">doSomethingElse(undefined)</span><br><span class="line">|<span class="string">---------------------------------</span>|</span><br><span class="line">                  finalHandler(resultOfDoSomething)</span><br><span class="line">                  |<span class="string">------------------</span>|</span><br></pre></td></tr></table></figure>
<p>Puzzle #4</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">doSomething</span>()<span class="selector-class">.then</span>(doSomethingElse)</span><br><span class="line">  <span class="selector-class">.then</span>(finalHandler);</span><br></pre></td></tr></table></figure>
<p>Answer:</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|<span class="string">-----------------</span>|</span><br><span class="line">                  doSomethingElse(resultOfDoSomething)</span><br><span class="line">                  |<span class="string">------------------</span>|</span><br><span class="line">                                     finalHandler(resultOfDoSomethingElse)</span><br><span class="line">                                     |<span class="string">------------------</span>|</span><br></pre></td></tr></table></figure>
<p>If these answers still don’t make sense, then I encourage you to re-read the post, or to define the doSomething() and doSomethingElse() methods and try it out yourself in your browser.</p>
<p>And for more advanced uses of promises, check out my promise protips cheat sheet.</p>
<p>Final word about promises</p>
<p>Promises are great. If you are still using callbacks, I strongly encourage you to switch over to promises. Your code will become smaller, more elegant, and easier to reason about.</p>
<p>And if you don’t believe me, here’s proof: a refactor of PouchDB’s map/reduce module to replace callbacks with promises. The result: 290 insertions, 555 deletions.</p>
<p>Incidentally, the one who wrote that nasty callback code was… me! So this served as my first lesson in the raw power of promises, and I thank the other PouchDB contributors for coaching me along the way.</p>
<p>That being said, promises aren’t perfect. It’s true that they’re better than callbacks, but that’s a lot like saying that a punch in the gut is better than a kick in the teeth. Sure, one is preferable to the other, but if you had a choice, you’d probably avoid them both.</p>
<p>While superior to callbacks, promises are still difficult to understand and error-prone, as evidenced by the fact that I felt compelled to write this blog post. Novices and experts alike will frequently mess this stuff up, and really, it’s not their fault. The problem is that promises, while similar to the patterns we use in synchronous code, are a decent substitute but not quite the same.</p>
<p>In truth, you shouldn’t have to learn a bunch of arcane rules and new APIs to do things that, in the synchronous world, you can do perfectly well with familiar patterns like return, catch, throw, and for-loops. There shouldn’t be two parallel systems that you have to keep straight in your head at all times.</p>
<p>Awaiting async/await</p>
<p>That’s the point I made in “Taming the asynchronous beast with ES7”, where I explored the ES7 async/await keywords, and how they integrate promises more deeply into the language. Instead of having to write pseudo-synchronous code (with a fake catch() method that’s kinda like catch, but not really), ES7 will allow us to use the real try/catch/return keywords, just like we learned in CS 101.</p>
<p>This is a huge boon to JavaScript as a language. Because in the end, these promise anti-patterns will still keep cropping up, as long as our tools don’t tell us when we’re making a mistake.</p>
<p>To take an example from JavaScript’s history, I think it’s fair to say that JSLint and JSHint did a greater service to the community than JavaScript: The Good Parts, even though they effectively contain the same information. It’s the difference between being told exactly the mistake you just made in your code, as opposed to reading a book where you try to understand other people’s mistakes.</p>
<p>The beauty of ES7 async/await is that, for the most part, your mistakes will reveal themselves as syntax/compiler errors rather than subtle runtime bugs. Until then, though, it’s good to have a grasp of what promises are capable of, and how to use them properly in ES5 and ES6.</p>
<p>So while I recognize that, like JavaScript: The Good Parts, this blog post can only have a limited impact, it’s hopefully something you can point people to when you see them making these same mistakes. Because there are still way too many of us who just need to admit: “I have a problem with promises!”<br>MeasureMeasure</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://dukegod.github.io/2017/04/10/2017-04-10-Javascript-Promise-problems/" data-id="cjobm5ymp003iva9ki1g7r36h" class="article-share-link">Share</a>
      
        <a href="http://dukegod.github.io/2017/04/10/2017-04-10-Javascript-Promise-problems/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Reprint/">Reprint</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/05/01/2017-05-01-Css-transition/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          理解CSS3 transition属性
        
      </div>
    </a>
  
  
    <a href="/2017/03/19/2017-03-19-Node-Nginx/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">node 中使用 nginx</div>
    </a>
  
</nav>

  
</article>
<!-- disqus -->

<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
 
<!-- 多说 -->
<!-- 

  -->
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ajax/">Ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/App/">App</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Google/">Google</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Graphgl/">Graphgl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hack/">Hack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Http/">Http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jquery/">Jquery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Less/">Less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Life/">Life</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lua/">Lua</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/">Nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node/">Node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pwa/">Pwa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reprint/">Reprint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sass/">Sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tools/">Tools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebAssembly/">WebAssembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/">Webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zepto/">Zepto</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openResty/">openResty</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Ajax/" style="font-size: 10px;">Ajax</a> <a href="/tags/App/" style="font-size: 17.5px;">App</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/Google/" style="font-size: 13.75px;">Google</a> <a href="/tags/Graphgl/" style="font-size: 10px;">Graphgl</a> <a href="/tags/Hack/" style="font-size: 13.75px;">Hack</a> <a href="/tags/Http/" style="font-size: 11.25px;">Http</a> <a href="/tags/Javascript/" style="font-size: 20px;">Javascript</a> <a href="/tags/Jquery/" style="font-size: 11.25px;">Jquery</a> <a href="/tags/Less/" style="font-size: 10px;">Less</a> <a href="/tags/Life/" style="font-size: 15px;">Life</a> <a href="/tags/Lua/" style="font-size: 10px;">Lua</a> <a href="/tags/Nginx/" style="font-size: 12.5px;">Nginx</a> <a href="/tags/Node/" style="font-size: 18.75px;">Node</a> <a href="/tags/Pwa/" style="font-size: 10px;">Pwa</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/Reprint/" style="font-size: 16.25px;">Reprint</a> <a href="/tags/Sass/" style="font-size: 11.25px;">Sass</a> <a href="/tags/Tools/" style="font-size: 13.75px;">Tools</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/WebAssembly/" style="font-size: 10px;">WebAssembly</a> <a href="/tags/Webpack/" style="font-size: 11.25px;">Webpack</a> <a href="/tags/Zepto/" style="font-size: 10px;">Zepto</a> <a href="/tags/openResty/" style="font-size: 10px;">openResty</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/19/2018-04-19-Graphgl/">Graphgl</a>
          </li>
        
          <li>
            <a href="/2018/04/11/2018-04-11-Pwa/">Pwa</a>
          </li>
        
          <li>
            <a href="/2018/04/10/2018-04-10-Node-Gzip/">Nodejs 项目中配置gzip</a>
          </li>
        
          <li>
            <a href="/2018/04/08/2018-04-08-Google-Amazing-Plugin/">谷歌浏览器超级赞的插件总结</a>
          </li>
        
          <li>
            <a href="/2018/04/05/2018-04-05-App-Performance/">前端性能调优</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 liu hui<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
  <div id="link">
  	<a href="https://github.com/dukegod">Github</a>
  	<a href="https://www.zhihu.com/people/dukegod">知</a>
  	<a href="https://www.quora.com/profile/Hui-Liu-37">Quora</a>
  	<a href="https://twitter.com/dukegod1991">Twitter</a>
  	<a href="https://www.facebook.com/profile.php?id=100009852840417">Facebook</a>
    <p style="margin-top:10px">
      <span id="busuanzi_container_site_pv">
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
      </span>
    </p>
  </div>
</footer>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about.html" class="mobile-nav-link">About</a>
  
    <a href="/resume.html" class="mobile-nav-link">Resume</a>
  
    <a href="/atom.xml" class="mobile-nav-link">rss</a>
  
</nav>
    
<script>
  var disqus_shortname = 'dukehui1991';
  
  var disqus_url = 'http://dukegod.github.io/2017/04/10/2017-04-10-Javascript-Promise-problems/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>